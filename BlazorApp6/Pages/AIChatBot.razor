@page "/ai-chat"
@implements IAsyncDisposable
@using Microsoft.AspNetCore.SignalR.Client
@using Markdig
@inject NavigationManager NavigationManager
@inject Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider AuthStateProvider
@inject StudentManager StudentManager
@inject IJSRuntime JS
@inject AiChatManager AiChatManager
@rendermode InteractiveServer

@* <div class="main-page">
<div class="chat-page"> *@
    @* <div class="sidebar p-3">
        <h5>AI Учител</h5>
        <p>Персонален помощник</p>
    </div> *@

<div class="main-chat-page">
    <div class="chat-page no-info">
    <div class="chat-container d-flex flex-column flex-grow-1">
            <div class="chat-window flex-grow-1 overflow-auto" style="padding-bottom: 80px;" @ref="chatWindowRef">

            @foreach (var m in messages.ToList())
            {
                if (m.SenderId == currentStudent.Id)
                {
                        @if (editingMessage != null && editingMessage.Id == m.Id)
                        {
                            <div class="my-message editing">
                                <input @bind="editingContent" class="edit-input" @ref="editingInputRef" />
                                <button class="btn btn-sm btn-success" @onclick="SaveEditedMessage">Запази</button>
                                <button class="btn btn-sm btn-secondary" @onclick="CancelEdit">Откажи</button>
                            </div>
                        }
                        else
                        {
                            <div class="my-message" @oncontextmenu:preventDefault="true" @oncontextmenu="@(e => ShowContextMenu(e, m))">
                                @((MarkupString)m.Content)
                                @if (m.IsEdited)
                                {
                                    <sub><small>редактирано </small></sub>
                                }
                            </div>
                        }
                }
                else
                {
                    <div class="other-message-sender">
                        @* <div class="other-message">
                            @((MarkupString)m.Content)
                        </div> *@
                        <div class="ai-message">
                            @((MarkupString)RenderMarkdown(m.Content))
                        </div>
                    </div>
                }
            }

            <div class="input-bar no-info d-flex align-items-center">
                @* <InputFile OnChange="OnInputFileSelected" /> *@
                <InputText @bind-Value="newMessage" placeholder="Задай въпрос..." />
                <button class="btn-send" disabled="@string.IsNullOrWhiteSpace(newMessage)"  @onclick="SendMessage">
                    <i class="bi bi-send"></i>
                </button>
            </div>
        </div>
    </div>
        @if (contextMenuVisible)
        {
            <div class="context-menu" style="top:@contextMenuYpx; left:@contextMenuXpx; position:absolute; z-index:1000;">
                <button class="btn btn-secondary" @onclick="EditMessage">Редактирай</button>
            </div>
        }
</div>
</div>

@code {
    private HubConnection? hubConnection;
    private Student currentStudent;
    private List<MessageForChat> messages = new();
    private string newMessage = "";

    private bool contextMenuVisible = false;
    private string contextMenuXpx, contextMenuYpx;
    private MessageForChat? selectedMessage;

    private MessageForChat? editingMessage = null;
    private string editingContent = string.Empty;

    private static readonly MarkdownPipeline _markdownPipeline =
    new MarkdownPipelineBuilder().UseAdvancedExtensions()
        .UseSoftlineBreakAsHardlineBreak().Build();

    private ElementReference chatWindowRef;
    private ElementReference editingInputRef;

    void OnAiTypingStarted(Guid tempId)
    {
        InvokeAsync(() =>
        {
            messages.Add(new MessageForChat(
                tempId,
                Guid.Empty,
                "AI Учител",
                "",
                DateTime.UtcNow,
                false,
                false
            ));
            StateHasChanged();
        });
    }

    void OnAiTypingChunk(Guid tempId, string chunk)
    {
        InvokeAsync(() =>
        {
            var msg = messages.FirstOrDefault(x => x.Id == tempId);
            if (msg != null)
            {
                msg.Content += chunk;
                StateHasChanged();
            }
        });
    }

    void OnAiTypingFinished(Guid tempId, Guid finalId)
    {
        InvokeAsync(() =>
        {
            var msg = messages.FirstOrDefault(x => x.Id == tempId);
            if (msg != null)
            {
                msg.Id = finalId;
            }
            else
            {
                messages.Add(new MessageForChat(finalId, Guid.Empty, "AI Учител", "", DateTime.UtcNow, false, false));
            }
            StateHasChanged();
            ScrollToBottomAsync();
        });
    }


    protected override async Task OnInitializedAsync()
    {
        var state = await AuthStateProvider.GetAuthenticationStateAsync();
        var username = state.User.Identity?.Name;

        currentStudent = StudentManager.FindStudent(s => s.Username == username);
        if (currentStudent == null) return;

        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/aichat"))
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<Guid, Guid, string, string>("ReceiveMessage",
            (id, senderId, sender, content) =>
            {
                messages.Add(new MessageForChat(id, senderId, sender, content, DateTime.Now, false, false));
                InvokeAsync(StateHasChanged);
                InvokeAsync(ScrollToBottomAsync);
            });

        hubConnection.Reconnected += async _ =>
        {
            await hubConnection.SendAsync("JoinChat",
                new UserConnection(Guid.Empty,
                    new StudentToConnect(currentStudent.Id, currentStudent.FirstName, currentStudent.SecName)));
        };  

        hubConnection.On<Guid>("AiTypingStarted", OnAiTypingStarted);
        hubConnection.On<Guid, string>("AiTypingChunk", OnAiTypingChunk);
        hubConnection.On<Guid, Guid>("AiTypingFinished", OnAiTypingFinished);

        hubConnection.On<Guid, string>("EditMessage", (messageId, newContent) =>
        {
            var msg = messages.FirstOrDefault(m => m.Id == messageId);
            if (msg != null)
            {
                msg.Content = newContent;
                msg.IsEdited = true;
                InvokeAsync(StateHasChanged);
            }
        });

        await hubConnection.StartAsync();

        await hubConnection.SendAsync("JoinChat",
            new UserConnection(Guid.Empty,
                new StudentToConnect(currentStudent.Id, currentStudent.FirstName, currentStudent.SecName)));
    }

    private string RenderMarkdown(string text)
    {
        return Markdown.ToHtml(text, _markdownPipeline);
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage) || hubConnection == null) return;

        await hubConnection.SendAsync("SendMessage",
            new UserConnection(Guid.Empty,
                new StudentToConnect(currentStudent.Id, currentStudent.FirstName, currentStudent.SecName)),
            new MessageToSend(Guid.NewGuid(), newMessage, DateTime.UtcNow));

        newMessage = "";
    }

    // private async Task OnInputFileSelected(InputFileChangeEventArgs e)
    // {
    //     var file = e.File;
    //     if (file == null || hubConnection == null) return;

    //     using var stream = file.OpenReadStream(20 * 1024 * 1024);
    //     using var ms = new MemoryStream();
    //     await stream.CopyToAsync(ms);

    //     await hubConnection.SendAsync("SendFile",
    //         new UserConnection(Guid.Empty,
    //             new StudentToConnect(currentStudent.Id, currentStudent.FirstName, currentStudent.SecName)),
    //         file.Name,
    //         ms.ToArray());
    // }

    private async Task EditMessage()
    {
        if (hubConnection == null) return;
        if (selectedMessage == null) return;
        if (currentStudent.Id != selectedMessage.SenderId) return;

        editingMessage = selectedMessage;
        editingContent = selectedMessage.Content;

        contextMenuVisible = false;
        selectedMessage = null;

        await Task.Delay(50);
        await editingInputRef.FocusAsync();
    }

    private async Task SaveEditedMessage()
    {
        if (editingMessage == null || hubConnection == null) return;

        await hubConnection.SendAsync("EditMessage",
            new UserConnection(Guid.Empty, new StudentToConnect(currentStudent.Id, currentStudent.FirstName, currentStudent.SecName)),
            editingMessage.Id,
            editingContent);

        editingMessage = null;
        editingContent = string.Empty;
    }

    private void CancelEdit()
    {
        editingMessage = null;
        editingContent = string.Empty;
    }

    private void ShowContextMenu(MouseEventArgs e, MessageForChat message)
    {
        selectedMessage = message;
        contextMenuXpx = $"{e.ClientX}px";
        contextMenuYpx = $"{e.ClientY}px";
        contextMenuVisible = true;
    }

    private void HideContextMenu()
    {
        contextMenuVisible = false;
        selectedMessage = null;
    }

    private async Task ScrollToBottomAsync()
    {
        await JS.InvokeVoidAsync("blazorScrollToBottom", chatWindowRef);
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
            await hubConnection.DisposeAsync();
    }
}
